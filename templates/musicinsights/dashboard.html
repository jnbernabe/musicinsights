{% extends "base.html" %} {% block header_content %} {% if playlist_name %}
<div style="display: flex; align-items: center; gap: 16px">
  <h2 style="margin: 0; font-size: 1.2rem; font-weight: 600">
    {{ playlist_name }}
  </h2>
  {% if playlist_vibe %}
  <span
    class="badge"
    style="
      background: linear-gradient(45deg, #ff00cc, #333399);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      box-shadow: 0 2px 10px rgba(255, 0, 204, 0.3);
      display: flex;
      align-items: center;
      gap: 6px;
    "
  >
    <i class="ph ph-sparkle"></i> {{ playlist_vibe }}
  </span>
  {% endif %}
</div>
{% endif %}

<!-- Active Filters in Navbar -->
<div
  id="navbar-filters"
  style="display: flex; align-items: center; gap: 8px; margin-left: 24px"
></div>
{% endblock %} {% block content %}

<!-- Tooltip Styles -->
<style>
  .info-icon {
    position: relative;
    margin-left: 8px;
    cursor: help;
    color: var(--text-secondary);
    font-size: 1.1rem;
    vertical-align: middle;
  }
  .info-icon:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
  }
  .tooltip-text {
    visibility: hidden;
    width: 220px;
    background: rgba(20, 20, 20, 0.95);
    backdrop-filter: blur(10px);
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 8px 12px;
    position: absolute;
    z-index: 9999;
    top: 120%; /* Show below the icon */
    left: 50%;
    margin-left: -110px;
    opacity: 0;
    transition: opacity 0.2s;
    font-family: "Inter", sans-serif;
    font-size: 0.75rem;
    line-height: 1.4;
    font-weight: normal;
    pointer-events: none;
    border: 1px solid #333;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  }
  /* Arrow pointing Up */
  .tooltip-text::after {
    content: "";
    position: absolute;
    bottom: 100%; /* Arrow at top of tooltip */
    top: auto;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent transparent rgba(20, 20, 20, 0.95) transparent; /* Bottom color visible */
  }
</style>

<!-- Bento Grid -->
<div class="bento-grid">
  <!-- Combined Stats & Insights -->
  <div
    class="bento-card col-span-1"
    style="display: flex; flex-direction: row; gap: 24px"
  >
    <!-- Stats Section (Left) -->
    <div
      style="
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
      "
    >
      <div class="card-header" style="margin-bottom: 0.5rem">
        <span class="card-title"
          ><i class="ph ph-music-notes card-icon"></i> Playlist Stats</span
        >
      </div>

      <div style="margin-bottom: 1.5rem">
        <div class="stat-value">{{ total_tracks }}</div>
        <div class="stat-sub">Total songs in playlist</div>
      </div>

      <div>
        <div class="stat-value">{{ total_listening_hours }}</div>
        <div class="stat-sub">Hours of listening time</div>
      </div>
    </div>

    <!-- Divider -->
    <div
      style="width: 1px; background: var(--card-border); margin: 10px 0"
    ></div>

    <!-- Insights Section (Right) -->
    <div style="flex: 1.5">
      <div class="card-header" style="margin-bottom: 0.5rem">
        <span class="card-title"
          ><i class="ph ph-sparkle card-icon"></i> Insights</span
        >
      </div>
      <ul
        style="
          list-style: none;
          padding: 0;
          margin: 0;
          color: var(--text-secondary);
          font-size: 1rem;
        "
      >
        {% for insight in text_insights %}
        <li
          style="
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
          "
        >
          <i
            class="ph ph-check-circle"
            style="
              color: var(--accent-primary);
              margin-top: 4px;
              flex-shrink: 0;
            "
          ></i>
          <span style="line-height: 1.4">{{ insight|safe }}</span>
        </li>
        {% empty %}
        <li>No insights available yet.</li>
        {% endfor %}
      </ul>
    </div>
  </div>

  <!-- Spotify Recommendations -->
  <div class="bento-card col-span-2" style="min-height: auto">
    <div class="card-header">
      <span class="card-title">
        <i class="fab fa-spotify card-icon" style="color: #1db954"></i>
        Essential Deep Cuts
      </span>
      {% if spotify_connected %}
      <span
        class="badge"
        style="
          background: rgba(29, 185, 84, 0.2);
          color: #1db954;
          padding: 4px 12px;
          border-radius: 20px;
          font-size: 0.8rem;
        "
        >Missing Hits from Your Top Artists</span
      >
      {% endif %}
    </div>

    {% if spotify_connected %} {% if spotify_recommendations %}
    <div class="recommendations-grid">
      {% for track in spotify_recommendations%}
      <a href="{{ track.external_url }}" target="_blank" class="track-card">
        {% if track.album_art %}
        <img
          src="{{ track.album_art }}"
          alt="{{ track.name }}"
          class="track-img"
        />
        {% else %}
        <div
          class="track-img"
          style="
            background: #222;
            display: flex;
            align-items: center;
            justify-content: center;
          "
        >
          <i class="ph ph-music-note"></i>
        </div>
        {% endif %}
        <div class="track-info">
          <h4>{{ track.name }}</h4>
          <p style="margin-bottom: 2px">{{ track.artists|join:", " }}</p>
          <small style="color: #1db954; font-size: 0.75rem"
            >{{ track.reason }}</small
          >
        </div>
      </a>
      {% endfor %}
    </div>
    {% else %}
    <div
      style="text-align: center; padding: 2rem; color: var(--text-secondary)"
    >
      <i
        class="ph ph-warning-circle"
        style="font-size: 2rem; margin-bottom: 1rem"
      ></i>
      <p>Could not generate recommendations. Ensure you have enough tracks.</p>
    </div>
    {% endif %} {% else %}
    <div style="text-align: center; padding: 3rem 1rem">
      <i
        class="fab fa-spotify"
        style="font-size: 3rem; color: #444; margin-bottom: 1rem"
      ></i>
      <h3 style="margin: 0 0 8px 0; color: #666">Service Unavailable</h3>
      <p style="color: var(--text-secondary); max-width: 400px; margin: 0 auto">
        Spotify integration is not configured on this server. Please contact the
        administrator to set up API keys.
      </p>
    </div>
    {% endif %}
  </div>

  <!-- Tracks Table -->
  <div class="bento-card col-span-1 row-span-1">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-playlist card-icon"></i>Tracks</span
      >
    </div>

    <!-- Active Filters Container -->
    <div
      id="active-filters"
      style="
        padding: 0 1.5rem 1rem 1.5rem;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        min-height: 0;
      "
    >
      <!-- Chips will be injected here by JS -->
    </div>

    <div class="table-container">
      <table>
        <thead>
          <tr>
            <th>Track</th>
            <th>Artist</th>
          </tr>
        </thead>
        <tbody id="track-table-body">
          <!-- Initial render from server (SEO/fallback), then JS takes over -->
          {% for t in top_tracks %}
          <tr>
            <td style="font-weight: 500">{{ t.name }}</td>
            <td>{{ t.artist }}</td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </div>
  <!-- Top Genres (Sunburst) -->
  <div class="bento-card col-span-1 row-span-2">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-chart-pie-slice card-icon"></i> Genres
        <i class="ph ph-info info-icon">
          <span class="tooltip-text"
            >Breakdown of the most common genres found in this playlist.</span
          >
        </i>
      </span>
    </div>
    <div id="genreChart" class="chart-container"></div>
  </div>
  <!-- Mood Map (Scatter) -->
  <div class="bento-card col-span-2 row-span-2">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-smiley card-icon"></i> Mood Map
        <i class="ph ph-info info-icon">
          <span class="tooltip-text"
            >Visualizes the emotional landscape based on Energy (Intensity) and
            Valence (Positivity).</span
          >
        </i>
      </span>
    </div>
    <div id="moodChart" class="chart-container"></div>
  </div>
  <!-- Tempo -->
  <div class="bento-card col-span-1 row-span-2">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-metronome card-icon"></i> Tempo
        <i class="ph ph-info info-icon">
          <span class="tooltip-text"
            >BPM (Beats Per Minute) distribution of your tracks.</span
          >
        </i>
      </span>
    </div>
    <div id="tempoChart" class="chart-container"></div>
  </div>

  <!-- Top Artists by Duration (Bar) -->
  <div class="bento-card col-span-1 row-span-3">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-clock card-icon"></i> Top Artists by Duration
        <i class="ph ph-info info-icon">
          <span class="tooltip-text"
            >Ranking of artists by the total time (in minutes) they take on your
            playlist.</span
          >
        </i>
      </span>
    </div>
    <div id="artistDurationChart" class="chart-container"></div>
  </div>
  <!-- Era Distribution -->
  <div class="bento-card col-span-1 row-span-1">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-hourglass card-icon"></i> Eras
        <i class="ph ph-info info-icon">
          <span class="tooltip-text"
            >Distribution of your music across different decades.</span
          >
        </i>
      </span>
    </div>
    <div id="eraChart" class="chart-container"></div>
  </div>

  <!-- Popularity -->
  <div class="bento-card col-span-1 row-span-1">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-trend-up card-icon"></i> Popularity
        <i class="ph ph-info info-icon">
          <span class="tooltip-text"
            >How mainstream (80-100) or obscure (0-20) your music taste
            is.</span
          >
        </i>
      </span>
    </div>
    <div id="popularityChart" class="chart-container"></div>
  </div>

  <!-- Artists Table -->
  <div class="bento-card col-span-1 row-span-1">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-users card-icon"></i>Artists</span
      >
    </div>
    <div class="table-container">
      <table>
        <thead>
          <tr>
            <th>Artist</th>
            <th>Tracks</th>
          </tr>
        </thead>
        <tbody id="top-artists-body">
          {% for name, count in top_artists %}
          <tr>
            <td style="font-weight: 500">{{ name }}</td>
            <td>{{ count }}</td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </div>

  <!-- Audio Features (Radar) -->
  <div class="bento-card col-span-2 row-span-2">
    <div class="card-header">
      <span class="card-title"
        ><i class="ph ph-faders card-icon"></i> Audio Profile
        <i class="ph ph-info info-icon">
          <span class="tooltip-text"
            >Average acoustic profile showing characteristics like Danceability
            and Acousticness.</span
          >
        </i>
      </span>
    </div>
    <div id="featuresChart" class="chart-container"></div>
  </div>
</div>
{% endblock %} {% block scripts %}
<script type="text/javascript">
  // Initialize ECharts Theme
  const theme = null;
  const bgColor = 'transparent';
  const accentColor = '#1DB954';
  const textColor = '#e0e0e0'; // Brighter text
  const axisLineColor = '#444';

  const commonTextStyle = {
      fontFamily: 'Inter, sans-serif',
      fontSize: 14,
      color: textColor
  };

  const axisLabelStyle = {
      color: textColor,
      fontSize: 13,
      fontFamily: 'Inter, sans-serif'
  };

  const titleStyle = {
      color: textColor,
      fontSize: 16,
      fontWeight: 600,
      fontFamily: 'Inter, sans-serif'
  };

  // --- Color Palette ---
  const colorPalette = [
    '#D32F2F', '#00897B', '#FBC02D', '#1B5E20', '#455A64',
    '#7B1FA2', '#0288D1', '#E64A19', '#512DA8', '#C2185B',
    '#388E3C', '#F57F17', '#0277BD', '#BF360C', '#6A1B9A',
    '#689F38', '#AD1457', '#00695C', '#FF8F00', '#4A148C',
    '#004D40', '#D84315', '#006064', '#880E4F', '#33691E'
  ];

  // Helper to init chart
  function initChart(id) {
    const dom = document.getElementById(id);
    if (!dom) return null;
    const chart = echarts.init(dom, theme, { renderer: 'canvas' });
    window.addEventListener('resize', () => chart.resize());
    return chart;
  }

  // Helper for No Data
  function getNoDataOption() {
    return {
      title: {
        text: 'No Data Available',
        left: 'center',
        top: 'center',
        textStyle: { color: '#888', fontSize: 16, fontWeight: 'normal' }
      }
    };
  }

  // --- Mood Map (Heatmap) ---
  const moodChart = initChart('moodChart');
  const moodData = {{ mood_data| safe }};

  // Helper to bin data for heatmap
  function getHeatmapData(sourceData) {
      // Grid: 10x10
      const bins = [];
      const gridSize = 10;
      for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
              bins.push([i, j, 0]); // x, y, count
          }
      }

      sourceData.forEach(item => {
          let v = item.x !== undefined ? item.x : item.valence;
          let e = item.y !== undefined ? item.y : item.energy;

          if (v !== undefined && e !== undefined) {
              const xIndex = Math.min(gridSize - 1, Math.floor(v * gridSize));
              const yIndex = Math.min(gridSize - 1, Math.floor(e * gridSize));
              const binIndex = xIndex * gridSize + yIndex;
              if (bins[binIndex]) bins[binIndex][2]++;
          }
      });
      return bins.filter(b => b[2] > 0);
  }

  if (!moodData || moodData.length === 0) {
    if (moodChart) moodChart.setOption(getNoDataOption());
  } else {
    // Initial Data
    const heatmapData = getHeatmapData(moodData);
    const maxCount = Math.max(...heatmapData.map(d => d[2]));

    // Generate Axes Labels (0.00, 0.10, ... 0.90)
    const axisLabels = [];
    for(let i=0; i<10; i++) axisLabels.push((i * 0.1).toFixed(1));

    if (moodChart) {
      moodChart.setOption({
        backgroundColor: bgColor,
        tooltip: {
          position: 'top',
          formatter: function (params) {
            return `Valence: ${(params.value[0] * 0.1).toFixed(2)} - ${(params.value[0] * 0.1 + 0.1).toFixed(2)}<br/>` +
                   `Energy: ${(params.value[1] * 0.1).toFixed(2)} - ${(params.value[1] * 0.1 + 0.1).toFixed(2)}<br/>` +
                   `Density: <b>${params.value[2]} tracks</b>`;
          },
          backgroundColor: 'rgba(20, 20, 20, 0.9)',
          borderColor: '#333',
          textStyle: { color: '#fff' }
        },
        grid: { top: 40, right: 60, bottom: 40, left: 60, containLabel: true },
        xAxis: {
          type: 'category',
          data: axisLabels,
          name: 'Valence (Happy)',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: textColor, fontSize: 13 },
          splitArea: { show: true, areaStyle: { color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0)'] } },
          axisLabel: axisLabelStyle
        },
        yAxis: {
          type: 'category',
          data: axisLabels,
          name: 'Energy',
          nameLocation: 'middle',
          nameGap: 40,
          nameTextStyle: { color: textColor, fontSize: 13 },
          splitArea: { show: true, areaStyle: { color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0)'] } },
          axisLabel: axisLabelStyle
        },
        visualMap: {
          min: 0,
          max: maxCount,
          calculable: true,
          orient: 'vertical',
          right: 0,
          top: 'center',
          inRange: {
            color: ['#2a2a2a', '#2d4b38', '#1db954', '#84bd00'] // Dark to Bright Green
          },
          textStyle: { color: textColor }
        },
        series: [{
          type: 'heatmap',
          data: heatmapData,
          emphasis: {
            itemStyle: {
              shadowBlur: 10,
              shadowColor: 'rgba(0, 0, 0, 0.5)'
            }
          },
          itemStyle: {
             borderColor: '#111',
             borderWidth: 1
          }
        }]
      });
    }
  }

  // --- Top Genres (Sunburst) ---
  const genreChart = initChart('genreChart');
  const rawGenreData = {{ top_genres| safe }};
  if (!rawGenreData || rawGenreData.length === 0) {
    if (genreChart) genreChart.setOption(getNoDataOption());
  } else {
    const genreData = rawGenreData.map(g => ({ name: g[0], value: g[1] }));
    if (genreChart) {
      genreChart.setOption({
        backgroundColor: bgColor,
        tooltip: { trigger: 'item' },
        series: {
          type: 'sunburst',
          data: genreData,
          radius: [0, '90%'],
          label: { rotate: 'radial', color: '#fff', fontSize: 12, fontWeight: 'bold' },
          itemStyle: {
            borderRadius: 4,
            borderWidth: 1,
            borderColor: '#111'
          },
          color: colorPalette
        }
      });
    }
  }

  // --- Top Artists by Duration (Bar) ---
  const artistDurationChart = initChart('artistDurationChart');
  const artistDurationLabels = {{ top_artists_duration_labels| safe }};
  const artistDurationValues = {{ top_artists_duration_values| safe }};
  if (!artistDurationLabels || artistDurationLabels.length === 0) {
    if (artistDurationChart) artistDurationChart.setOption(getNoDataOption());
  } else {
    if (artistDurationChart) {
      artistDurationChart.setOption({
        backgroundColor: bgColor,
        tooltip: { trigger: 'axis' },
        grid: { top: 20, right: 30, bottom: 20, left: 120, containLabel: true },
        xAxis: {
          type: 'value',
          name: 'Minutes',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: textColor, fontSize: 13 },
          splitLine: { lineStyle: { color: '#333' } },
          axisLabel: axisLabelStyle
        },
        yAxis: {
          type: 'category',
          data: artistDurationLabels.reverse(),
          axisLine: { lineStyle: { color: '#444' } },
          axisLabel: {
            color: textColor,
            fontSize: 13,
            fontFamily: 'Inter, sans-serif',
            interval: 0,
            width: 110,
            overflow: 'truncate'
          }
        },
        series: [{
          data: artistDurationValues.reverse(),
          type: 'bar',
          itemStyle: {
            color: new echarts.graphic.LinearGradient(1, 0, 0, 0, [
              { offset: 0, color: '#1DB954' },
              { offset: 1, color: 'rgba(29, 185, 84, 0.1)' }
            ]),
            borderRadius: [0, 4, 4, 0]
          }
        }]
      });
    }
  }

  // --- Audio Features (Radar) ---
  const featuresChart = initChart('featuresChart');
  const featureLabels = {{ feature_labels| safe }};
  const avgFeatures = {{ avg_features| safe }};
  // Check if all features are 0 or empty
  if (!avgFeatures || avgFeatures.length === 0 || avgFeatures.every(v => v === 0)) {
    if (featuresChart) featuresChart.setOption(getNoDataOption());
  } else {
    if (featuresChart) {
      featuresChart.setOption({
        backgroundColor: bgColor,
        tooltip: {},
        radar: {
          center: ['50%', '50%'],
          radius: '65%',
          indicator: featureLabels.map((f, i) => ({
            name: f,
            max: 1,
            color: colorPalette[i % colorPalette.length]
          })),
          splitArea: { areaStyle: { color: ['transparent'] } },
          splitLine: { lineStyle: { color: '#333' } },
          axisLine: { lineStyle: { color: '#333' } },
          axisName: { fontSize: 13 }
        },
        polar: {
          center: ['50%', '50%'],
          radius: '65%'
        },
        angleAxis: {
          type: 'category',
          data: featureLabels,
          boundaryGap: false,
          splitLine: { show: false },
          axisLine: { show: false },
          axisLabel: { show: false },
          startAngle: 90,
          clockwise: false
        },
        radiusAxis: {
          min: 0,
          max: 1,
          axisLine: { show: false },
          axisLabel: { show: false },
          splitLine: { show: false }
        },
        series: [{
          type: 'radar',
          symbolSize: 0,
          data: [{
            value: avgFeatures,
            name: 'Average Profile',
            areaStyle: { color: colorPalette[1] + '4D' },
            lineStyle: { color: colorPalette[1] },
            itemStyle: { color: colorPalette[1] }
          }]
        }, {
          type: 'scatter',
          coordinateSystem: 'polar',
          symbolSize: 8,
          data: avgFeatures.map((val, i) => ({
            value: [val, i],
            itemStyle: {
              color: colorPalette[i % colorPalette.length],
              borderColor: '#fff',
              borderWidth: 1
            }
          })),
          z: 10
        }]
      });
    }
  }

  // --- Time of Day (Pie/Nightingale) ---
  const timeChart = initChart('timeChart');
  const timeLabels = {{ time_of_day_labels| safe }};
  const timeValues = {{ time_of_day_values| safe }};

  if (!timeValues || timeValues.every(v => v === 0)) {
    if (timeChart) timeChart.setOption(getNoDataOption());
  } else {
    // Combine labels and values
    const data = timeLabels.map((label, index) => ({
      name: label,
      value: timeValues[index]
    }));

    if (timeChart) {
      timeChart.setOption({
        backgroundColor: bgColor,
        tooltip: { trigger: 'item' },
        series: [{
          type: 'pie',
          radius: [20, 80],
          roseType: 'area',
          itemStyle: { borderRadius: 5 },
          data: data.map(item => {
            let color = '#A8E6CF';
            if (item.name === 'Morning') color = '#FFE66D';
            if (item.name === 'Afternoon') color = '#4ECDC4';
            if (item.name === 'Evening') color = '#FF6B6B';
            return { ...item, itemStyle: { color: color } };
          })
        }]
      });
    }
  }

  // --- Eras (Bar) ---
  const eraChart = initChart('eraChart');
  const eraLabels = {{ era_labels| safe }};
  const eraValues = {{ era_values| safe }};
  if (!eraLabels || eraLabels.length === 0) {
    if (eraChart) eraChart.setOption(getNoDataOption());
  } else {
    if (eraChart) {
      eraChart.setOption({
        backgroundColor: bgColor,
        tooltip: { trigger: 'axis' },
        grid: { top: 10, right: 10, bottom: 30, left: 10, containLabel: true },
        xAxis: { type: 'category', data: eraLabels, axisLabel: axisLabelStyle },
        yAxis: { type: 'value', show: false },
        series: [{
          data: eraValues.map((val, idx) => ({
            value: val,
            itemStyle: { color: colorPalette[idx % colorPalette.length], borderRadius: 4 }
          })),
          type: 'bar'
        }]
      });
    }
  }

  // --- Popularity (Donut) ---
  const popularityChart = initChart('popularityChart');
  const popLabels = {{ popularity_labels| safe }};
  const popValues = {{ popularity_values| safe }};
  if (!popLabels || popLabels.length === 0) {
    if (popularityChart) popularityChart.setOption(getNoDataOption());
  } else {
    const popData = popLabels.map((label, i) => ({ name: label, value: popValues[i] }));
    if (popularityChart) {
      popularityChart.setOption({
        backgroundColor: bgColor,
        tooltip: { trigger: 'item' },
        legend: { bottom: 0, textStyle: { color: textColor } },
        series: [{
          name: 'Popularity',
          type: 'pie',
          radius: ['40%', '70%'],
          avoidLabelOverlap: false,
          itemStyle: {
            borderRadius: 10,
            borderColor: bgColor,
            borderWidth: 2
          },
          label: { show: false, position: 'center' },
          emphasis: {
            label: { show: true, fontSize: 20, fontWeight: 'bold', color: '#fff' }
          },
          labelLine: { show: false },
          data: popData,
          color: colorPalette
        }]
      });
    }
  }

  // --- Tempo (Line) ---
  const tempoChart = initChart('tempoChart');
  const tempoLabels = {{ tempo_labels| safe }};
  const tempoValues = {{ tempo_values| safe }};
  if (!tempoLabels || tempoLabels.length === 0) {
    if (tempoChart) tempoChart.setOption(getNoDataOption());
  } else {
    if (tempoChart) {
      tempoChart.setOption({
        backgroundColor: bgColor,
        tooltip: { trigger: 'axis' },
        grid: { top: 20, right: 20, bottom: 30, left: 40, containLabel: true },
        xAxis: { type: 'category', data: tempoLabels, axisLabel: axisLabelStyle }, // Removed boundaryGap: false
        yAxis: { type: 'value', splitLine: { lineStyle: { color: '#333' } }, axisLabel: axisLabelStyle },
        series: [{
          data: tempoValues,
          type: 'bar', // Changed from line to bar
          itemStyle: {
              color: colorPalette[3],
              borderRadius: [4, 4, 0, 0] // Rounded top
          }
        }]
      });
    }
  }
  // --- Interactive Filtering Logic ---

  // 1. Data Injection
  const allTracks = {{ all_tracks_json| safe }};
  let activeFilters = {
    era: null,
    genre: null,
    popularity: null,
    tempo: null,
    timeOfDay: null
  };

  // 2. Render Functions
  function renderTable(tracks) {
      const tbody = document.getElementById('track-table-body');
      if (!tbody) return;

      tbody.innerHTML = '';

      if (tracks.length === 0) {
          tbody.innerHTML = '<tr><td colspan="2" style="text-align: center; padding: 2rem; color: #888;">No tracks match these filters.</td></tr>';
          return;
      }

      // Determine limit: 10 if no filters, 50 if filtered
      // const hasActiveFilters = Object.values(activeFilters).some(v => v !== null);
      // const limit = hasActiveFilters ? 50 : 10;
      // UNLIMITED tracks as requested

      // Show limit tracks
      tracks.forEach(t => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td style="font-weight: 500">${t.name}</td>
            <td>${t.artist}</td>
          `;
          tbody.appendChild(row);
      });
  }

  function renderTopArtists(tracks) {
      const tbody = document.getElementById('top-artists-body');
      if (!tbody) return;

      tbody.innerHTML = '';

      if (tracks.length === 0) {
          tbody.innerHTML = '<tr><td colspan="2" style="text-align: center; padding: 2rem; color: #888;">No data.</td></tr>';
          return;
      }

      // Count artists
      const artistCounts = {};
      tracks.forEach(t => {
          if (t.artist) {
              // Split by comma and strip whitespace to count individuals
              const individuals = t.artist.split(',').map(a => a.trim());
              individuals.forEach(artist => {
                  if (artist) {
                      artistCounts[artist] = (artistCounts[artist] || 0) + 1;
                  }
              });
          }
      });

      // Sort and slice
      const sortedArtists = Object.entries(artistCounts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10); // Keep to top 10 for display

      sortedArtists.forEach(([name, count]) => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td style="font-weight: 500">${name}</td>
            <td>${count}</td>
          `;
          tbody.appendChild(row);
      });
  }

    function updateActiveFiltersDisplay() {
        const container = document.getElementById('navbar-filters');
        if (!container) return;

        container.innerHTML = '';

        const activeKeys = Object.keys(activeFilters).filter(k => activeFilters[k] !== null);

        // Hide if no filters
        if (activeKeys.length === 0) {
            container.style.display = 'none';
            return;
        }

        container.style.display = 'flex'; // Show when we have filters

        // divider
        const divider = document.createElement('div');
        divider.style.height = '24px';
        divider.style.width = '1px';
        divider.style.backgroundColor = 'var(--card-border)';
        divider.style.marginRight = '12px';
        container.appendChild(divider);

        activeKeys.forEach(key => {
            const val = activeFilters[key];
            const chip = document.createElement('div');
            chip.className = 'filter-chip';
            chip.style.cssText = `
                background: rgba(29, 185, 84, 0.1);
                border: 1px solid var(--accent-primary);
                color: var(--accent-primary);
                padding: 4px 12px;
                border-radius: 100px;
                font-size: 0.8rem;
                display: flex;
                align-items: center;
                gap: 6px;
                cursor: pointer;
            `;
            chip.innerHTML = `<span>${key}: ${val}</span> <i class="ph ph-x"></i>`;
            chip.onclick = () => toggleFilter(key, null); // Clear specific filter
            container.appendChild(chip);
        });

        // Clear All
        if (activeKeys.length > 0) { // Changed from > 1 to > 0 to show clear all even with one filter
            const clearBtn = document.createElement('button');
            clearBtn.innerText = 'Clear All';
            clearBtn.style.cssText = `
                background: transparent;
                border: none;
                color: var(--text-muted);
                font-size: 0.8rem;
                cursor: pointer;
                padding: 4px 8px;
            `;
            clearBtn.onmouseover = () => clearBtn.style.color = '#fff';
            clearBtn.onmouseout = () => clearBtn.style.color = 'var(--text-muted)';
            clearBtn.onclick = () => {
                activeFilters = { era: null, genre: null, timeOfDay: null, popularity: null, tempo: null };
                applyFilters();
            };
            container.appendChild(clearBtn);
        }
    }

  // 3. Filter Logic
  function applyFilters() {
      let filtered = allTracks;

      if (activeFilters.era) filtered = filtered.filter(t => t.era === activeFilters.era);
      if (activeFilters.genre) filtered = filtered.filter(t => t.genres.includes(activeFilters.genre));
      if (activeFilters.popularity) filtered = filtered.filter(t => t.popularity_bucket === activeFilters.popularity);
      if (activeFilters.tempo) filtered = filtered.filter(t => t.tempo_bucket === activeFilters.tempo);
      if (activeFilters.timeOfDay) filtered = filtered.filter(t => t.time_of_day === activeFilters.timeOfDay);

      renderTable(filtered);
      renderTopArtists(filtered);
      updateActiveFiltersDisplay();
      updateCharts(filtered);
  }

  function toggleFilter(category, value) {
      if (value === null) {
          activeFilters[category] = null;
          applyFilters();
          return;
      }
      if (activeFilters[category] === value) {
          activeFilters[category] = null;
      } else {
          activeFilters[category] = value;
      }
      applyFilters();
  }

  // 4. Client-side Aggregation & Chart Updates
  function updateCharts(tracks) {
      if (!tracks) return;

      // -- Era --
      const eraCounts = {};
      tracks.forEach(t => { if(t.era) eraCounts[t.era] = (eraCounts[t.era] || 0) + 1; });
      const sortedEras = Object.keys(eraCounts).sort();
      if (eraChart) {
          eraChart.setOption({
              xAxis: { data: sortedEras },
              series: [{
                  data: sortedEras.map((e, i) => ({
                      value: eraCounts[e],
                      itemStyle: {
                          color: colorPalette[i % colorPalette.length],
                          borderRadius: 4
                      }
                  }))
              }]
          });
      }

      // -- Genre --
      const genreCounts = {};
      tracks.forEach(t => { t.genres.forEach(g => genreCounts[g] = (genreCounts[g] || 0) + 1); });
      const sortedGenres = Object.entries(genreCounts).sort((a,b) => b[1] - a[1]).slice(0, 10);
      if (genreChart) {
          genreChart.setOption({
              series: { data: sortedGenres.map(g => ({ name: g[0], value: g[1] })) }
          });
      }

      // -- Popularity --
      const popCounts = {};
      const popOrder = ['0-20', '21-40', '41-60', '61-80', '81-100'];
      tracks.forEach(t => { if(t.popularity_bucket) popCounts[t.popularity_bucket] = (popCounts[t.popularity_bucket] || 0) + 1; });
      if (popularityChart) {
          const popData = popOrder.filter(k => popCounts[k]).map(k => ({ name: k, value: popCounts[k] }));
          popularityChart.setOption({ series: [{ data: popData }] });
      }

      // -- Tempo --
      const tempoCounts = {};
      const tempoOrder = ['<80 BPM', '80-100 BPM', '100-120 BPM', '120-140 BPM', '>140 BPM'];
      tracks.forEach(t => { if(t.tempo_bucket) tempoCounts[t.tempo_bucket] = (tempoCounts[t.tempo_bucket] || 0) + 1; });
      if (tempoChart) {
           const tData = tempoOrder.map(k => tempoCounts[k] || 0);
           tempoChart.setOption({
               xAxis: { data: tempoOrder },
               series: [{
                   type: 'bar',
                   data: tData,
                   itemStyle: {
                       color: colorPalette[3],
                       borderRadius: [4, 4, 0, 0]
                   }
               }]
           });
      }

      // -- Time of Day --
      const timeCounts = {};
      tracks.forEach(t => { if(t.time_of_day) timeCounts[t.time_of_day] = (timeCounts[t.time_of_day] || 0) + 1; });
      if (timeChart) {
          const tLabels = Object.keys(timeCounts);
          const tData = tLabels.map(l => ({
              name: l,
              value: timeCounts[l],
              itemStyle: { color: l === 'Morning' ? '#FFE66D' : l === 'Afternoon' ? '#4ECDC4' : l === 'Evening' ? '#FF6B6B' : '#A8E6CF' }
          }));
          timeChart.setOption({ series: [{ data: tData }] });
      }

      // -- Audio Features --
      const features = ['danceability', 'energy', 'valence', 'acousticness', 'instrumentalness', 'liveness', 'speechiness'];
      const totals = {};
      features.forEach(f => totals[f] = 0);
      let count = 0;
      tracks.forEach(t => {
          let hasData = false;
          features.forEach(f => {
              if (t[f] !== undefined && t[f] !== null) {
                  totals[f] += t[f];
                  hasData = true;
              }
          });
          if (hasData) count++;
      });
      const avgs = features.map((f) => count ? (totals[f] / count).toFixed(3) : 0);

      if (featuresChart) {
          featuresChart.setOption({
              series: [
                  { data: [{ value: avgs, name: 'Average Profile', areaStyle: { color: colorPalette[1] + '4D' }, lineStyle: { color: colorPalette[1] }, itemStyle: { color: colorPalette[1] } }] },
                  { data: avgs.map((val, i) => ({ value: [val, i], itemStyle: { color: colorPalette[i % colorPalette.length], borderColor: '#fff', borderWidth: 1 } })) }
              ]
          });
      }

      // -- Mood Map --
      if (moodChart) {
          const newData = getHeatmapData(tracks);
          const newMax = Math.max(...newData.map(d => d[2]));

          moodChart.setOption({
              visualMap: { max: newMax },
              series: [{ data: newData }]
          });
      }

      // -- Top Artists Duration --
       const artistDur = {};
       tracks.forEach(t => {
           const mainArtist = t.artist.split(',')[0];
           artistDur[mainArtist] = (artistDur[mainArtist] || 0) + (t.duration_ms || 0);
       });
       const sortedArtists = Object.entries(artistDur).sort((a,b) => b[1] - a[1]).slice(0, 10);

       if (artistDurationChart) {
           artistDurationChart.setOption({
               yAxis: { data: sortedArtists.map(a => a[0]).reverse() },
               series: [{ data: sortedArtists.map(a => (a[1] / (1000*60)).toFixed(1)).reverse() }]
           });
       }
  }

  // 4. Attach Handlers to Charts
  // Ensure charts exist before adding listeners
  if (eraChart) eraChart.on('click', params => toggleFilter('era', params.name));
  if (genreChart) genreChart.on('click', params => toggleFilter('genre', params.name));
  if (popularityChart) popularityChart.on('click', params => toggleFilter('popularity', params.name));
  if (tempoChart) tempoChart.on('click', params => toggleFilter('tempo', params.name));

  // TimeChart (Pie)
  // If we used Nightingale/Pie, params.name is the label
  if (timeChart) timeChart.on('click', params => toggleFilter('timeOfDay', params.name));

  console.log("Interactive Filtering Loaded. Total Tracks:", allTracks.length);
</script>
{% endblock %}
